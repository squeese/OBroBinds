local scope = select(2, ...)

scope.ACTION = { kind = 1, id = 2, name = 3, icon = 4, locked = 5, SPELL = 6, MACRO = 6, ITEM = 6, BLOB = 6 }

function scope.ACTION:__index(key)
  if self == scope.empty then return end
  local val = scope.ACTION[key]
  if type(val) ~= 'number' then
    return val
  elseif val == 6 then
    return rawget(self, 1) == key
  else
    return rawget(self, val)
  end
  return value
end

function scope.ACTION:SetOverrideBinding(binding)
  if self.SPELL then
    SetOverrideBindingSpell(scope.root, false, binding, GetSpellInfo(self.id) or self.name)
  elseif self.MACRO then
    SetOverrideBindingMacro(scope.root, false, binding, self.name)
  elseif self.ITEM then
    SetOverrideBindingItem(scope.root, false, binding, self.name)
  elseif self.BLOB then
  else
    SetOverrideBinding(scope.root, false, binding, nil)
  end
end

function scope.ACTION:Icon()
  if self.SPELL then
    return select(3, GetSpellInfo(self.id)) or self.icon 
  elseif self.MACRO then
    return select(2, GetMacroInfo(self.name)) or self.icon
  elseif self.ITEM then
    return select(10, GetItemInfo(self.id or 0)) or self.icon
  elseif self.BLOB then
    return 441148
  end
  return self.icon or nil
end

function scope.dbActionIterator(...)
  local k, v = next(...)
  return k, setmetatable(v or scope.empty, scope.ACTION)
end

function scope.dbActions()
  return scope.dbActionIterator, scope.read(OBroBindsDB, scope.class, scope.spec) or scope.empty
end

function scope.dbGetAction(binding)
  return setmetatable(scope.read(OBroBindsDB, scope.class, scope.spec, binding) or scope.empty, scope.ACTION)
end

do
  local function save(action, ...)
    for i = 1, select("#", ...) do
      action[i] = select(i, ...)
    end
    return action
  end
  function scope.dbSaveAction(binding, ...)
    OBroBindsDB = scope.write(OBroBindsDB, scope.class, scope.spec, binding, save, ...)
    local action = setmetatable(scope.read(OBroBindsDB, scope.class, scope.spec, binding) or scope.empty, scope.ACTION)
    action:SetOverrideBinding(binding)
  end
end


function scope.dbToggleActionLock(binding)
  local value = not scope.dbGetAction(binding).locked and true or nil
  OBroBindsDB = scope.write(OBroBindsDB, scope.class, scope.spec, binding, scope.ACTION.locked, value)
end

function scope.dbDeleteAction(binding)
  OBroBindsDB = scope.write(OBroBindsDB, scope.class, scope.spec, binding, nil)
  SetOverrideBinding(scope.root, false, binding, nil)
end


function scope.dbPromoteToAction(binding)
end

function scope.dbRead(...)
  return scope.read(OBroBindsDB, ...)
end

function scope.dbWrite(...)
  OBroBindsDB = scope.write(OBroBindsDB, ...)
end

function scope.UpdatePlayerBindings(next, ...)
  ClearOverrideBindings(scope.root)
  scope.class = select(2, UnitClass("player"))
  scope.spec = GetSpecialization()
  for binding, action in scope.dbActions() do
    action:SetOverrideBinding(binding)
  end
  return next(...)
end

function scope.UpdateUnknownSpells(e, ...)
  for binding, action in scope.dbActions() do
    if action.SPELL and not action.id then
      local icon, _, _, _, id = select(3, GetSpellInfo(action.name))
      action[1], action[4] = id, icon or action.icon
    end
  end
  return e(...)
end

do
  local elapsed, pa, pc, ps, modifier = 0, IsAltKeyDown(), IsControlKeyDown(), IsShiftKeyDown()
  local function OnUpdate(self, delta)
    elapsed = elapsed + delta
    if elapsed < 0.1 then return end
    local na, nc, ns = IsAltKeyDown(), IsControlKeyDown(), IsShiftKeyDown()
    if pa ~= na or pc ~= nc or ps ~= ns then
      pa, pc, ps = na, nc, ns
      scope.modifier = (pa and "ALT-" or "")..(pc and "CTRL-" or "")..(ps and "SHIFT-" or "")
      scope:dispatch("ADDON_MODIFIER_CHANGED")
    end
    elapsed = 0
  end
  function scope.InitializePageKeyboard(e, ...)
    scope.pageKeyboard:SetScript("OnUpdate", OnUpdate)
    scope.modifier = (IsAltKeyDown() and "ALT-" or "")..(IsControlKeyDown() and "CTRL-" or "")..(IsShiftKeyDown() and "SHIFT-" or "")
    scope.buttons = {}
    scope.offset = 1
    scope.mainbar = nil
    scope.stances = nil
    if scope.class == "ROGUE" then
      scope.write(scope, 'stances', scope.push, scope.createStanceButton(73,  'ability_stealth',            1, 2, 3))
    elseif true or scope.class == "DRUID" then
      scope.write(scope, 'stances', scope.push, scope.createStanceButton(97,  'ability_racial_bearform',    1, 2, 3, 4))
      scope.write(scope, 'stances', scope.push, scope.createStanceButton(73,  'ability_druid_catform',      1, 2, 3, 4))
      scope.write(scope, 'stances', scope.push, scope.createStanceButton(109, 'spell_nature_forceofnature', 1))
    end
    scope.createStanceButton = nil
    return e(scope.DEFAULT_KEYBOARD_LAYOUT, ...)
  end
end

function scope.UpdateKeyboardStanceButtons(e, ...)
  if scope.stances then
    local prev
    for _, button in ipairs(scope.stances) do
      button:Hide()
      if scope.match(scope.spec, unpack(button)) then
        button:Show()
        button:ClearAllPoints()
        if not prev then
          button:SetPoint("LEFT", scope.pageKeyboard, "TOPLEFT", 0, -36)
        else
          button:SetPoint("LEFT", prev, "RIGHT", 4, 0)
        end
        button.Border:Hide()
        if scope.offset == button.offset then
          button.Border:Show()
        end
        prev = button
      end
    end
  end
  return e(...)
end

do
  local function UpdateButton(self)
    local binding = scope.modifier..self.key
    if scope.mainbar[binding] then
      local kind, id = GetActionInfo(scope.mainbar[binding] + scope.offset - 1)
      self.Border:Show()
      self.Name:SetText(scope.mainbar[binding])
      self.icon:SetVertexColor(1, 1, 1, 1)
      if kind == 'spell' then
        self.icon:SetTexture(select(3, GetSpellInfo(id)))
      elseif kind == 'macro' then
        self.icon:SetTexture(select(2, GetMacroInfo(id)))
      elseif kind == 'item' then
        self.icon:SetTexture(select(10, GetItemInfo(id)))
      else
        self.icon:SetTexture(nil)
      end
    else
      self.Border:Hide()
      self.Name:SetText()
      local action = scope.dbGetAction(binding)
      local hasAction = GetBindingAction(binding, false) ~= ""
      local icon = action.kind and action:Icon()
      if icon then
        self.icon:SetVertexColor(1, 1, 1, 1)
        self.icon:SetTexture(icon)
      elseif hasAction then
        self.icon:SetVertexColor(0.8, 1, 0.1, 0.1)
        self.icon:SetTexture(136243)
      else
        self.icon:SetTexture(nil)
      end
      if hasAction then
        self.AutoCastable:Show()
      else
        self.AutoCastable:Hide()
      end
      if action.locked then
        self.LevelLinkLockIcon:Show()
      else
        self.LevelLinkLockIcon:Hide()
      end
    end
  end

  local padding, mmin, mmax = 12, math.min, math.max
  function scope.UpdateKeyboardLayout(e, layout, ...)
    scope.index = 0
    scope.pageKeyboard:ClearAllPoints()
    scope.pageKeyboard:SetPoint("TOPLEFT", padding, -padding)
    scope.pageKeyboard:SetSize(1, 1)
    local xmin, xmax = scope.pageKeyboard:GetLeft(), scope.pageKeyboard:GetRight()
    local ymin, ymax = scope.pageKeyboard:GetBottom(), scope.pageKeyboard:GetTop()
    local button
    for key in pairs(scope.buttons) do
      if type(key) == "string" then
        scope.button[key] = nil
      end
    end
    for i = 1, #layout, 3 do
      scope.index = scope.index + 1
      if scope.index > #scope.buttons then
        button = scope.createActionButton()
        button.UpdateButton = UpdateButton
        table.insert(scope.buttons, button)
      else
        button = scope.buttons[scope.index]
      end
      local key, x, y = select(i, unpack(layout))
      button.key = key
      scope.buttons[key] = button
      button:SetPoint("TOPLEFT", x, -y-58)
      button.Border:Hide()
      button.Border:SetAlpha(1)
      button.HotKey:SetText(key)
      button.Name:SetText()
      xmin = mmin(xmin, button:GetLeft())
      xmax = mmax(xmax, button:GetRight())
      ymin = mmin(ymin, button:GetBottom())
      ymax = mmax(ymax, button:GetTop())
    end
    for i = scope.index+1, #scope.buttons do
      button = scope.buttons[scope.index]
      button:Hide()
    end
    local w, h = xmax-xmin, ymax-ymin
    scope.root:SetSize(w+padding*2, h+padding*2)
    scope.pageKeyboard:SetSize(w, h)
    return e(...)
  end
end

do
  local pattern = "^(.--?)([^-]*.)$"
  local function UpdateButton(binding)
    local modifier, key = string.match(binding, pattern)
    if scope.modifier == modifier then
      scope.buttons[key]:UpdateButton()
    end
  end
  local prev
  function scope.UpdateKeyboardMainbarIndices(e, ...)
    prev, scope.mainbar = scope.mainbar, scope.clean(prev or {})
    for index = 1, 12 do
      local binding = GetBindingKey("ACTIONBUTTON"..index)
      if binding then
        scope.mainbar[binding] = index
        scope.dbDeleteAction(binding)
        if prev then
          if prev[binding] ~= scope.mainbar[binding] then
            UpdateButton(binding)
          end
          prev[binding] = nil
        end
      end
    end
    if prev then
      for binding in pairs(prev) do
        UpdateButton(binding)
      end
    end
    return e(...)
  end

  function scope.UpdateKeyboardMainbarSlots(e, slot, ...)
    local index = slot-scope.offset+1
    local binding = GetBindingKey("ACTIONBUTTON"..index)
    if binding and 1 <= index and index <= 12 then
      assert(scope.mainbar[binding] == index)
      UpdateButton(binding)
    end
    return e(slot, ...)
  end

  function scope.UpdateKeyboardMainbarOffsets(e, ...)
    for binding, index in pairs(scope.mainbar) do
      UpdateButton(binding)
    end
    return e(...)
  end
end

function scope.UpdateAllKeyboardButtons(e, ...)
  for index = 1, scope.index do
    scope.buttons[index]:UpdateButton()
  end
  return e(...)
end

do
  local function Update(button)
    if not button:IsVisible() then return end
    GameTooltip:SetOwner(button, 'ANCHOR_BOTTOMRIGHT')
    local binding = scope.modifier..button.key
    if scope.mainbar[binding] then
      GameTooltip:SetAction(scope.mainbar[binding] + scope.offset - 1)
      return
    end
    local action = scope.dbGetAction(binding)
    if action.SPELL then
      if action.id and GetSpellInfo(action.id) then
        GameTooltip:SetSpellByID(action.id)
      else
        GameTooltip:SetText("SPELL "..action.name)
      end
    elseif action.MACRO then
      GameTooltip:SetText("MACRO "..action.name)
    elseif action.ITEM then
      local level = select(4, GetItemInfo(action.id or 0))
      if action.id and level then
        GameTooltip:SetItemKey(action.id, level, 0)
      else
        GameTooltip:SetText("ITEM "..action.name)
      end
    elseif action.BLOB then
      GameTooltip:SetText("BLOB "..action.id)
    elseif GetBindingAction(binding, false) ~= "" then
      GameTooltip:SetText(GetBindingAction(binding, false))
    elseif GetBindingAction(binding, true) ~= "" then
      GameTooltip:SetText(GetBindingAction(binding, true))
    else
      GameTooltip:Hide()
    end
  end
  local current
  function scope.UpdateTooltip(e, button, ...)
    current = button
    Update(button)
    return e(button, ...)
  end
  function scope.RefreshTooltip(e, ...)
    if current and GetMouseFocus() == current then
      Update(current)
    end
    return e(...)
  end
end

--function _A.PromoteOverrideEntry(e, frame, binding)
  --local action = GetBindingAction(binding, false)
  --local kind, name = string.match(action, "^(%w+) (.*)$")
  --if kind == 'SPELL' then
    --local icon, _, _, _, id = select(3, GetSpellInfo(name))
    --assert(name ~= nil)
    --frame:dispatch("SET_OVERRIDE_ENTRY", true, binding, kind, id, name, icon or 134400)
  --elseif kind == 'MACRO' then
    --local id = GetMacroIndexByName(name)
    --local icon = select(2, GetMacroInfo(name))
    --assert(name ~= nil)
    --frame:dispatch("SET_OVERRIDE_ENTRY", true, binding, kind, id, name, icon or 134400)
  --elseif kind == 'ITEM' then
    --local link, _, _, _, _, _, _, _, icon = select(2, GetItemInfo(name))
    --local id = link and select(4, string.find(link, "^|c%x+|H(%a+):(%d+)[|:]"))
    --assert(name ~= nil)
    --frame:dispatch("SET_OVERRIDE_ENTRY", true, binding, kind, id, name, icon or 134400)
  --else
    --assert(false, "Unhandled type: "..kind)
  --end
  --return e:next(frame, binding)
--end

do
  --local function CURSOR_UPDATE(e, frame)
    --frame.__cursor = nil
    --frame:UnregisterEvent("CURSOR_UPDATE")
    --return e:once(frame)
  --end
  function scope.PickupOverrideBinding(e, button, ...)
    local binding = scope.modifier..button.key
    if scope.mainbar[binding] then
      PickupAction(scope.mainbar[binding] + scope.offset - 1)
      return e(button, ...)
    end
    local action = scope.dbGetAction(binding)
    if not action.locked then
      if action.SPELL then
        PickupSpell(action.id)
        --if not GetCursorInfo() then
          --local macro = CreateMacro("__OBRO_TMP", select(3, GetSpellInfo(id)) or icon)
          --PickupMacro(macro)
          --DeleteMacro(macro)
          --root.__cursor = read(OBroBindsDB, root.class, root.spec, binding)
          --root:RegisterEvent("CURSOR_UPDATE")
          --_A.listen("CURSOR_UPDATE", CURSOR_UPDATE)
        --end
      elseif action.MACRO then
        PickupMacro(action.name)
      elseif action.ITEM then
        PickupItem(action.id)
      elseif action.kind then
        assert(false, "Unhandled pickup: "..action.kind)
      end
      scope.dbDeleteAction(binding)
    end
    return e(button, ...)
  end
end

function scope.ReceiveOverrideBinding(e, button, ...)
  print("receive", button.key)
  local binding = scope.modifier..button.key
  if scope.mainbar[binding] then
    PlaceAction(scope.mainbar[binding] + scope.offset - 1)
    return e(button, ...)
  end

  if not scope.dbGetAction(binding).locked then
    local kind, id, link, arg1, arg2 = GetCursorInfo()

    if kind == "spell" then
      ClearCursor()
      scope:dispatch("ADDON_PICKUP_OVERRIDE_BINDING", button)
      local id = arg2 or arg1
      local name, _, icon = GetSpellInfo(id)
      assert(id ~= nil)
      assert(name ~= nil)
      assert(icon ~= nil)
      scope.dbSaveAction(binding, strupper(kind), id, name, icon)

    --elseif kind == "macro" and id == 0 then
      --local action = root.__cursor
      --ClearCursor()
      --root:dispatch("PICKUP_OVERRIDE_ENTRY", button)
      --root:dispatch("SET_OVERRIDE_ENTRY", true, binding, action[KIND], action[ID], action[NAME], action[ICON])

    elseif kind == "macro" then
      ClearCursor()
      scope:dispatch("ADDON_PICKUP_OVERRIDE_BINDING", button)
      local name, icon = GetMacroInfo(id)
      assert(type(id) == "number")
      assert(id ~= nil)
      assert(name ~= nil)
      assert(icon ~= nil)
      scope.dbSaveAction(binding, strupper(kind), id, name, icon)

    elseif kind == "item" then
      ClearCursor()
      local name = select(3, string.match(link, "^|c%x+|H(%a+):(%d+).+|h%[([^%]]+)"))
      local icon = select(10, GetItemInfo(id))
      assert(link ~= nil)
      assert(name ~= nil)
      assert(icon ~= nil)
      scope:dispatch("ADDON_PICKUP_OVERRIDE_BINDING", button)
      scope.dbSaveAction(binding, strupper(kind), id, name, icon)

    elseif kind then
      assert(false, "Unhandled receive: "..kind)
    end
  end
  return next(button)
end
